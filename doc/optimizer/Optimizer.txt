* Building & Running
  Steps to build and run our DAMAJ Decaf Compiler.
  
  These instructions assume you are running on Athena.
  
  Clone the repository or otherwise obtain a copy of the code.

  Run ~add -f scala~. use ~scala -version~ to make sure that scala is using version 2.11.2.
  We use ~fsc~ to compile scala a little faster. If you happen to have any trouble because of weird
  fsc version conflicts, please try killing your fsc server (find it with ~ps aux | grep fsc~).
  Don't set any env variables like ~SCALA_HOME~ as this could force you to use the wrong version
  of scala.
  
  Once you have the right version of scala run ~make~ or ~build.sh~ to compile the project.
  If you have trouble with this or later steps, try `make clean` to reset the build files.
  
  Now you should be able to run the compiler using run.sh.

  To enable optimizations you can add ~-O all~.

  For example:

  ~./run.sh --debug tests/codegen/input/01-callout.dcf -O all~

  ~./run.sh --debug tests/codegen/input/04-math2.dcf -o 04-math2.asm~

  Alternatively, you can use ~compile.sh~ to compile and run a program.
  ~./compile.sh tests/codegen/input/01-callout.dcf~
  This will assemble the program into ~tmp/out.S~, print the assembly, create an executable at ~tmp/out~,
  and run the executable, printing its output as well. This will not work for programs which need to be
  linked to external libraries, for those please use ~run.sh~ or another script.
  
* Optimizations
  Some of the optimizations below were previously described in `doc/data_flow/DataFlowAnalysis.pdf`.
  They are described here again because many described before were disabled and have since been enabled.
  
  Most optimizations use analyses from `src/scala/dataflow`.

** Interface

  TODO describe the interface

** Common Subexpression Elimination
    Operates on: Set of Expressions
    Available Expressions Analysis is a forward-running algorithm that determines wether an expressions variables are reassigned before the block. 
    Every assignment to x removes any expressions in the state that depend on variable x 
     
  Here is an example of CSE optimization. Please note that the blocks were given names for debugging 
  purposes, and that circular nodes are forking conditions.

  Before: 

  #+ATTR_LaTeX: width=0.4\textwidth
  [[./before_cse.png]]
  
  After CSE:

  #+ATTR_LaTeX: width=0.4\textwidth
  [[./after_cse.png]]

  Notice that CSE temps are generated for the expressions ~0~, ~a+b~, and ~c+d~, and also that ~c+d~
  appropriately is available for the last statement after it became available in each input branch. 

  TODO convince the reader that the optimization is beneficial
  TODO convince the reader that the optimization is general
  TODO convince the reader that the optimization is correct

** Unreachable Code Elimination
    Unreachable code elimination, located in ~src/scala/transform/UnreachableCodeElim.scala~, 
    deletes portions of code which can never be reached. It consumes the Reachable analysis. Any 
    block code deemed unreachable by Reachable is turned into a nop block with no statements. The 
    nop blocks are cleaned up in a later pass by the Condenser.

    Here is an example of UCE at work. Note that the blocks after the return in the if are not cleared because they could occur, but the blocks after the definitive return are cleared.

    TODO convince the reader that the optimization is beneficial
    TODO convince the reader that the optimization is general
    TODO convince the reader that the optimization is correct

** Dead Code Elimination
  If there is an assignment to a dead variable, it is first checked for whether it is a method call. 
  If it is, it is converted simply to a method call without an assignment. Otherwise, the assignment
  to a dead variable is removed completely. 

  Here is an example of before and after Dead Code Elimination runs. Please note that the blocks were
  given names for debugging purposes, and that circular nodes are forking conditions.

  Before: 

  #+ATTR_LaTeX: width=0.4\textwidth
  [[./before_deadcode_example.png]]
  
  After dead code elimination:

  #+ATTR_LaTeX: width=0.4\textwidth
  [[./after_deadcode_example.png]]

  Notice that the dead statements have been removed (the now-empty blocks will be removed in a later step).

  TODO convince the reader that the optimization is beneficial
  TODO convince the reader that the optimization is general
  TODO convince the reader that the optimization is correct

** Copy Propogation
  TODO describe DCE
  TODO convince the reader that the optimization is beneficial
  TODO convince the reader that the optimization is general
  TODO convince the reader that the optimization is correct

** Order

  TODO The order in which optimizations are applied.

* CFG Graph Generation
    A visual representation of the cfg we generate is a very useful debugging tool. 
    Graphiz is a simple and straightforward interface that takes a definition of graph, and
    produces a svg, pdf,png, or ps file with a visualization of the graph.
    We installed the dot package to show our directed graph
    To aid in debugging, we implemented a ~grapher.scala~ that takes in a CFG,
    and creates an output .gv (same as .dot) file.

** Generating Graphs
   First, make sure you have the `graphviz` package installed on your computer, which provides the program
   `dot`. Then, you can run `graph.sh` with the code. `graph.sh` takes all the same arguments that you can
   pass in to `run.sh`, so for example you could pass in only one optimization. It will generate a graph
   before and after each optimization pass, as well as generating annotated graphs for each analysis. 
   The last pass will condense blocks into more reasonable basic blocks.

   The graphs will be output in the `tmp` folder. 

   Try running:

   `./graph.sh -O all tests/dataflow/input/cse-01.dcf`

   And check out the output graphs!
